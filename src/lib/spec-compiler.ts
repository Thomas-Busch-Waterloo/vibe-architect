import { Conversation } from "@/types";

/**
 * Compiles a conversation into a single master-spec.md file.
 */
export function compileSingleFile(conversation: Conversation): string {
    const sections = extractSections(conversation);
    const timestamp = new Date().toISOString().split("T")[0];

    return `# ${conversation.title} â€” Implementation Spec
> Generated by Vibe Architect on ${timestamp}

---

## 1. Vision & Scope
${sections.vision || "_Not yet defined_"}

---

## 2. Design System
${sections.design || "_Not yet defined_"}

---

## 3. Tech Stack & Architecture
${sections.stack || "_Not yet defined_"}

---

## 4. Implementation Plan
${sections.implementation || "_Not yet defined_"}

---

## Appendix: Full Conversation Log
${formatConversationLog(conversation)}
`;
}

/**
 * Compiles a conversation into 4 separate files for ZIP export.
 */
export function compileMultiFile(
    conversation: Conversation
): Record<string, string> {
    const sections = extractSections(conversation);
    const timestamp = new Date().toISOString().split("T")[0];
    const header = (title: string) =>
        `# ${title}\n> Project: ${conversation.title}\n> Generated: ${timestamp}\n\n---\n\n`;

    return {
        "@01-vision.md":
            header("Vision & Scope") + (sections.vision || "_Not yet defined_"),
        "@02-design.md":
            header("Design System") + (sections.design || "_Not yet defined_"),
        "@03-stack.md":
            header("Tech Stack & Architecture") +
            (sections.stack || "_Not yet defined_"),
        "@04-implementation.md":
            header("Implementation Plan") +
            (sections.implementation || "_Not yet defined_"),
    };
}

interface Sections {
    vision: string;
    design: string;
    stack: string;
    implementation: string;
}

function extractSections(conversation: Conversation): Sections {
    const allAssistantContent = conversation.messages
        .filter((m) => m.role === "assistant")
        .map((m) => m.content)
        .join("\n\n---\n\n");

    // Try to split by common section markers the AI uses
    const sections: Sections = {
        vision: "",
        design: "",
        stack: "",
        implementation: "",
    };

    // Simple heuristic: look for keyword-based section headers
    const visionPatterns =
        /(?:##?\s*(?:1\.?\s*)?(?:Vision|MVP|Scope|Features|Product)[\s\S]*?)(?=##?\s*(?:2\.?\s*)?(?:Design|Visual|UI)|$)/i;
    const designPatterns =
        /(?:##?\s*(?:2\.?\s*)?(?:Design|Visual|UI|Colors|Typography|Vibe)[\s\S]*?)(?=##?\s*(?:3\.?\s*)?(?:Tech|Stack|Architecture|Backend)|$)/i;
    const stackPatterns =
        /(?:##?\s*(?:3\.?\s*)?(?:Tech|Stack|Architecture|Backend|Frontend)[\s\S]*?)(?=##?\s*(?:4\.?\s*)?(?:Implementation|Steps|Phases|Plan)|$)/i;
    const implementationPatterns =
        /(?:##?\s*(?:4\.?\s*)?(?:Implementation|Steps|Phases|Plan)[\s\S]*?)$/i;

    const visionMatch = allAssistantContent.match(visionPatterns);
    const designMatch = allAssistantContent.match(designPatterns);
    const stackMatch = allAssistantContent.match(stackPatterns);
    const implementationMatch = allAssistantContent.match(implementationPatterns);

    if (visionMatch) sections.vision = visionMatch[0].trim();
    if (designMatch) sections.design = designMatch[0].trim();
    if (stackMatch) sections.stack = stackMatch[0].trim();
    if (implementationMatch)
        sections.implementation = implementationMatch[0].trim();

    // Fallback: if no sections found, dump everything into implementation
    if (!sections.vision && !sections.design && !sections.stack) {
        sections.implementation = allAssistantContent;
    }

    return sections;
}

function formatConversationLog(conversation: Conversation): string {
    return conversation.messages
        .map((m) => {
            const role = m.role === "user" ? "**User**" : "**Architect**";
            const time = new Date(m.timestamp).toLocaleTimeString();
            return `### ${role} (${time})\n${m.content}`;
        })
        .join("\n\n---\n\n");
}
